#define MAXSIZE 10

//静态查找：
//1.顺序查找，时间复杂性O(n)
int SeauentialSearch(List Tb1, int K)
{
	int i;
	Tb1->Element[0] = K;//建立哨兵
	for(i = Tb1->Length; Tb1->Element[i] != K; i--);//可以不用判断i>0这个条件
	return i;
}

typedef struct LNode* List;
struct LNode {
	int Element[MAXSIZE];
	int Length;
};

//2.二分查找，O(log2n)
//前提：元素的关键字有序，且元素连续存放（数组）
int BinarySearch(List Tbl, int K) {
	int Left, Right, Mid;
	Left = 1;
	Right = Tbl->Length;
	while (Left <= Right)
	{
		Mid = (Left + Right) / 2;
		if (Tbl->Element[Mid] < K) {
			Left = Mid + 1;
		}
		else if (Tbl->Element[Mid] > K) {
			Right = Mid - 1;
		}
		else return Mid;
	}
	return -1;
}

//儿子―兄弟表示法，再旋转45度
//构成二叉树（指针最多有两个），且有左右之分
//特殊的二叉树：斜二叉树，完美/满二叉树，完全二叉树
//完全二叉树：即从上到下从左往右依次排序
//对任何非空二叉树，n0表示叶结点个数,n2表示度为2的结点个数，那么两者关系满足n0=n2+1
//边数 = 节点数-1即n0+n1+n2-1 （往上看）= 0*n0 + 1*n1 + 2*n2（往下看）


//判定树上每个结点需要的查找次数刚好等于该结点所在的层数
//查找成功时的查找次数不会超过判定树的深度
//n个结点的判定树的深度为(log2n) + 1

//树的定义：树有一个称为根的特殊节点，其余结点可分为m个互不相交的子集，称为子树
//”递归“
//除了根节点外，每个结点有且仅有一个父节点
//含N个结点的树有N-1条边
//基本术语：
//结点的度：结点的子树个数
//树的度：树中所有结点的最大的度数
//叶结点：度为0的结点
//父节点：有子树的结点是其子树的根节点的父节点
//子节点：与父节点对应
//兄弟结点：具有同一父节点的各结点彼此是兄弟结点
//路径和路径长度：从结点n1到nk的路径是一个结点序列，ni是ni+1的父节点路径包含的边的个数为路径的长度
//也就是说路径要从上往下才算吗
//祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点
//子孙结点：某一结点的子树的所有结点都是这个结点的子孙
//结点的层次：规定根节点在1层，其他任意结点的层数都是其父节点的层数+1
//树的深度：树中的最大层次是这棵树的深度